\documentclass[ngerman,hyperref={pdfpagelabels=false}]{beamer}

% -----------------------------------------------------------------------------

\graphicspath{{images/}}

% -----------------------------------------------------------------------------

\usetheme{KIT}

\setbeamercovered{transparent}
%\setbeamertemplate{enumerate items}[ball]

\newenvironment<>{KITtestblock}[2][]
{\begin{KITcolblock}<#1>{#2}{KITblack15}{KITblack50}}
{\end{KITcolblock}}

\usepackage[ngerman,english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[TS1,T1]{fontenc}
\usepackage{array}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{beamerKITdefs}
\usepackage{amsfonts}


\pdfpageattr {/Group << /S /Transparency /I true /CS /DeviceRGB>>}	%required to prevent color shifting withd transparent images


\title{Tutorium 42, \#6}
\subtitle{Max Göckel-- \textit{uzkns@student.kit.edu}}

\author[Max Göckel]{Max Göckel}
\institute{Institut für Theoretische Informatik - Grundbegriffe der Informatik}

\TitleImage[width=\titleimagewd,height=\titleimageht]{titel}

\KITinstitute{Institut f\"ur Theoretische Informatik}
\KITfaculty{Fakult\"at f\"ur Informatik}

% -----------------------------------------------------------------------------

\begin{document}
\setlength\textheight{7cm} %required for correct vertical alignment, if [t] is not used as documentclass parameter


% title frame
\begin{frame}
  \maketitle
\end{frame}


%Übungsblatt häufige Fehler
\begin{frame}
\frametitle{Übungsblatt: Häufige Fehler}
\begin{itemize}
	\item 1.a): $G = (((\neg A)\vee B)\rightarrow B)$ $\rightarrow$ gesamten Audruck umklammern!
	\item 2) "Beweisen sie induktiv folgende Aussage" $\rightarrow$ Bis zum Ende rechnen und Folgerung aufschreiben!
	\item 4) Auf den folgenden Folien
	\item 6.abcd) Begründung $\not=$ Beweis!
	\item Induktiv definieren ist nicht gleich induktivem Beweisen. man braucht zwar auch einen IA und eine Art IS aber es gilt nicht irgendeine Aussage zu beweisen.
\end{itemize}
\end{frame}


%Modus Ponens und Aussagen beweisen
\begin{frame}
\frametitle{Beweisbarkeit von Aussagen}

Drei Axiome:
\begin{itemize}
	\item ${Ax}_{AL1} = \{ (G \rightarrow (H \rightarrow G)) | G,H \in For_{AL} \}$
	\item ${Ax}_{AL2} = \{ ( G \rightarrow (H \rightarrow K)) \rightarrow ((G \rightarrow H) \rightarrow (G \rightarrow K)) | G,H,K, \in For_{AL} \}$
	\item ${Ax}_{AL3} = \{ (\neg H \rightarrow \neg G) \rightarrow (( \neg H \rightarrow G) \rightarrow H) | G,H \in For_{AL} \}$ 
\end{itemize}

\ \\
Modus Ponens: $MP = \{ (G \rightarrow H, G, H) | G, H \in For_{AL} \}$
\end{frame}

%Beispiel
\begin{frame}
\frametitle{Beweisbarkeit von Aussagen: Aufgabe aus dem ÜB}
Mit den Aximon und ggf. Prämissen kann man jede Aussage G "ableiten".\\
\ \\
Prämissen: $\{ A \rightarrow B, A \rightarrow \neg B \}$, Formel: $F = \neg A$\\
\begin{enumerate}
	\item $A \rightarrow B$, Prämisse $P_1$
	\item $A \rightarrow \neg B$, Prämisse $P_2$
	\item $(A \rightarrow B) \rightarrow ((A \rightarrow \neg B) \rightarrow \neg A)$, $Ax_{AL3}$  ($G = \neg B, H = \neg A$)
	\item $(A \rightarrow \neg B) \rightarrow \neg A$, MP(3.,1.)
	\item $\neg A$, MP(4.,2.)
\end{enumerate}
\end{frame}



%Induktiv definieren
\begin{frame}
\frametitle{Induktive Definition}
Alphabet A, formale Sprache $L = \{ w | w \in A^{*}, |w| = 2^n , n \in \mathbb{N} _0 \}$.\\
\ \\
Startwert: $L_1 = A$
Induktiv also: $\forall n \in \mathbb{N}^+ : L_{n+1} = A \cdot L_n$\\
oder: $\forall n \in \mathbb{N}^+ : L_{n+1} = L_n \cdot L_n$.\\
Definiert uns $L_n$ für alle $n \in \mathbb{N}^+$\\
\ \\
Hire aufhören reicht nicht, wir haben zwar alle $L_n$ definiert aber nicht L insgesamt.
\end{frame}

%Aufgabe
\begin{frame}
\frametitle{Speicher: Aufgabe}
Wie sieht $m_3$ nach der folgenden verketteten Operation auf Tabelle $m_2$ aus?\\
\ \\
\begin{itemize}
	\item $m_3 = memwrite(m_2, 11, memread(memwrite(m_2, 10, 000), 00))$
\end{itemize}
\ \\
\ \\
$m_2$:
\begin{tabular}{c|c}
Stelle & Wert \\ \hline
00 & 010 \\
01 & 000 \\
10 & 111 \\
11 & 100 \\
\end{tabular}
\end{frame}


%LÖSUNG%
\begin{frame}
\frametitle{Speicher: Lösung}
Wie sieht $m_3$ nach der folgenden verketteten Operation auf Tabelle $m_2$ aus?\\
\ \\
\begin{itemize}
	\item $m_3 = memwrite(m_2, 11, memread(memwrite(m_2, 10, 000), 00))$
\end{itemize}
\ \\
\ \\
$m_3$:
\begin{tabular}{c|c}
Stelle & Wert \\ \hline
00 & 010 \\
01 & 000 \\
10 & 111 \\
11 & 010 \\
\end{tabular}
\end{frame}


%Aufgabe%
\begin{frame}
\frametitle{Die MIMA: Aufgabe}
Was tut das folgende Programm?\\
\ \\
LDC 1 \\
STV 011 \\
LDV 010 \\
NOT \\
ADD 011 \\
ADD 001 \\
JMN here \\
LDC 1 \\
STV 111 ;result\\
JMP end \\
here: LDC 0 \\
STV 111 ;result\\
end: HALT
\end{frame}


%Aufgabe%
\begin{frame}
\frametitle{Die MIMA: Aufgabe}
Beschreibt die folgenden Befehle.\\
\ \\
JMP a\\
LDV a\\
HALT\\
ADD a\\
\end{frame}


%LÖSUNG%
\begin{frame}
\frametitle{Die MIMA: Aufgabe}
Beschreibt die folgenden Befehle.\\
\ \\
JMP a: Springt zum Befehl an Stelle a (oder in GBI: Mit Markierung a)\\
LDV a: Lädt den Wert an Adresse a in den Akku\\
HALT: Stoppt die MIMA\\
ADD a: Addiert den Wert an Adresse a auf den Akku drauf (Ergebnis landet wieder im Akku)\\
\end{frame}


%Aufgabe%
\begin{frame}
\frametitle{Die MIMA: Aufgabe}
Schreibe ein Programm, dass den Wert an Adresse 001 verdreifacht.
\end{frame}


%LÖSUNG%
\begin{frame}
\frametitle{Die MIMA: Lösung}
Schreibe ein Programm, dass den Wert an Adresse 001 verdreifacht.\\
\ \\
LDV 001 \\
ADD 001 \\
ADD 001 \\
STV 001 \\
HALT.
\end{frame}





%Aufgabe%
\begin{frame}
\frametitle{Die MIMA: Aufgabe}
Was tut das folgende Programm?\\
\ \\
LDV adr1 \\
NOT \\
STV adr2 \\
LDC 1 \\
ADD adr2 \\
STV adr3 \\
HALT \\
\end{frame}


%LÖSUNG%
%LÖSUNG%
\begin{frame}
\frametitle{Die MIMA: Aufgabe}
Was tut das folgende Programm?\\
\ \\
Es bildet das Zweierkomplement von adr1 und speichert es an adr3.
\end{frame}


%Aufgabe
\begin{frame}
\frametitle{Die MIMA: Aufgaben}
1) Schreibe ein Programm dass für ein $x \geq 0$ an Adresse adr \emph{x div 2} ausführt und und das Ergebnis wieder in adr abspeichert. \\
2) Schreibe ein Programm, das für den Wert x an der Adresse \emph{001} x mod 2 berechnet und das Ergebnis wieder in x speichert. \\
3) An Speicherstelle adr1 steht ein Wert x $\geq$ 1.\\
Schreibe ein Programm, dass den Wert an adr2 mit x multipliziert (adr $\cdot$ x)\\
\ \\
Die Lösungen stehen im ILIAS.
\end{frame}


%MIMA Befehle
\begin{frame}
\frametitle{Die MIMA: Befehle}
LDC c - lädt Konstante c in den Akku \\
LDV a - Lädt Wert an Stelle a in den Akku \\
STV a - speicher Wert vom Akku in Stelle a \\
ADD a - Addiert Wert an Stelle a auf den Wert im Akku drauf (Ergebn. $\rightarrow$ Akku) \\
AND a - VerUNDet Wert v.St. a und Akku $\rightarrow$ Akku \\
OR a - VerODERt Wert v.St. a und Akku $\rightarrow$ Akku \\
XOR a - VerXORt Wert v.St. a und Akku $\rightarrow$ Akku \\
EQL a - Falls Akku = Wert a.St. a $\rightarrow$ Akku -1 in Akku, sonst 0 \\
JMP a - Springt zum Befehl mit Marker a \\
JMN a - Springt zum Befehl a wenn Akku < 0 \\
HALT - Endet die Auführung der MIMA \\
NOT - Invertiert den Akku (0 $\rightarrow$ 1, 1 $\rightarrow$ 0) \\
RAR - Rotiert den Akku um eins nach rechts\\
\ \\
Der Wert des Akku wird immer überschreiben wenn man neue Werte lädt, also Werte die man mehrfach braucht zwischenspeichern (STV).
\end{frame}




\end{document}
